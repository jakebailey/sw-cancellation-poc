{
  "version": 3,
  "sources": ["../src/sw/common.ts", "../src/sw/sw.ts"],
  "sourcesContent": ["import type * as rpc from 'vscode-jsonrpc/browser';\n\nconst cancellationPathMarker = '/@cancellation@/';\n\nexport function isCancellationPath(path: string): boolean {\n    return path.includes(cancellationPathMarker);\n}\n\n// Returns relative paths to ensure a subpath doesn't break.\nexport function cancellationPath(requestId: rpc.CancellationId): string {\n    return `.${cancellationPathMarker}${requestId}`;\n}\n\nfunction isClientSource(source: ExtendableMessageEvent['source']): source is Client {\n    if (source && typeof (source as Client).id === 'string') {\n        return true;\n    }\n    return false;\n}\n\nexport interface SetCanceledEventData {\n    readonly type: 'setCanceled';\n    readonly id: rpc.CancellationId;\n}\n\nexport interface SetCanceledEvent extends ExtendableMessageEvent {\n    readonly data: SetCanceledEventData;\n    readonly source: Client;\n}\n\nexport namespace SetCanceledEvent {\n    export function is(e: ExtendableMessageEvent): e is SetCanceledEvent {\n        return (\n            e.data.type === 'setCanceled' &&\n            isClientSource(e.source) &&\n            (typeof e.data.id === 'number' || typeof e.data.id === 'string')\n        );\n    }\n}\n\nexport interface DeleteCanceledEventData {\n    readonly type: 'deleteCanceled';\n    readonly id: rpc.CancellationId;\n}\n\nexport interface DeleteCanceledEvent extends ExtendableMessageEvent {\n    readonly data: DeleteCanceledEventData;\n    readonly source: Client;\n}\n\nexport namespace DeleteCanceledEvent {\n    export function is(e: ExtendableMessageEvent): e is DeleteCanceledEvent {\n        return (\n            e.data.type === 'deleteCanceled' &&\n            isClientSource(e.source) &&\n            (typeof e.data.id === 'number' || typeof e.data.id === 'string')\n        );\n    }\n}\n\nconst rpcPathMarker = '/@rpc@/';\n\nexport function isRpcPath(path: string): boolean {\n    return path.includes(rpcPathMarker);\n}\n\n// Returns relative paths to ensure a subpath doesn't break.\nexport function rpcPath(): string {\n    return `.${rpcPathMarker}`;\n}\n\nexport interface RpcRequest {\n    method: string;\n    params: any;\n}\n\nexport interface RpcResponse {\n    result: any;\n}\n\nexport interface RpcError {\n    error: {\n        code: number;\n        message: string;\n    };\n}\n\nexport interface SwLogMessage {\n    type: 'log';\n    message: string;\n}\n\nexport interface SwRpcMessage {\n    type: 'rpc';\n    request: RpcRequest;\n    port: MessagePort;\n}\n\nexport type SwMessage = SwLogMessage | SwRpcMessage;\n", "/// <reference lib=\"webworker\" />\n\nimport { debug } from '../debug';\nimport {\n    cancellationPath,\n    DeleteCanceledEvent,\n    isCancellationPath,\n    isRpcPath,\n    RpcRequest,\n    RpcResponse,\n    SetCanceledEvent,\n    SwLogMessage,\n    SwRpcMessage,\n} from './common';\n\ndeclare const self: ServiceWorkerGlobalScope;\nexport {};\n\nconst cacheName = 'v1';\n\n// Since caches are shared, create a unique path for the specific client.\nfunction getCachePath(pathname: string, clientId: string): string {\n    return pathname + '/' + clientId;\n}\n\nasync function setCanceled(pathname: string, clientId: string) {\n    const cachePath = getCachePath(pathname, clientId);\n    const cache = await self.caches.open(cacheName);\n    cache.put(cachePath, new Response('', { status: 200 }));\n}\n\nasync function setCanceledResponse(pathname: string, clientId: string): Promise<Response> {\n    setCanceled(pathname, clientId);\n    return new Response('', { status: 200 });\n}\n\nasync function getCanceledResponse(pathname: string, clientId: string): Promise<Response> {\n    debug && console.log(`sw: getCanceledResponse ${pathname}`);\n    const cachePath = getCachePath(pathname, clientId);\n    const cache = await self.caches.open(cacheName);\n    const canceled = await cache.match(cachePath);\n    return canceled ?? new Response('', { status: 299 });\n}\n\nasync function deleteCanceled(pathname: string, clientId: string) {\n    const cachePath = getCachePath(pathname, clientId);\n    const cache = await self.caches.open(cacheName);\n    cache.delete(cachePath);\n}\n\nasync function deleteCanceledResponse(pathname: string, clientId: string) {\n    deleteCanceled(pathname, clientId);\n    return new Response('', { status: 200 });\n}\n\nself.addEventListener('install', (e) => {\n    debug && console.log('sw: installed');\n    // Don't bother waiting for a previous service worker to exit.\n    self.skipWaiting();\n});\n\nself.addEventListener('activate', (e) => {\n    e.waitUntil(async () => {\n        debug && console.log('sw: activated');\n        // TODO: figure out the right semantics here. Service workers are \"sticky\",\n        // in that an old service worker will just stick around until all of its pages\n        // are closed, before the new worker is even able to touch those pages.\n        // The general reasoning is that a service worker with a specific version\n        // should not be able to affect pages which did not request a service worker\n        // of that version. Maybe this is okay; the main thing is that we want to ensure\n        // that the frontend page code (even after a reload) can assume that it's paired\n        // with the correct version of the service worker.\n        // See also: https://web.dev/service-worker-lifecycle/\n        //           https://github.com/w3c/ServiceWorker/issues/1296\n\n        // Grab control of any uncontrolled pages. Normally, a service worker would\n        // only grab control of pages after a reload, but we want control the moment\n        // the page loads, including the page that first started the service worker.\n        await self.clients.claim();\n\n        // Delete the cache to prevent buildup (as the browser will not prune the cache);\n        // at worst we can't cancel a few pending requests.\n        // TODO: do we need to do this so much now that token deletion has been\n        // implemented? What about using a local variable instead?\n        await self.caches.delete(cacheName);\n    });\n});\n\nself.addEventListener('message', (e) => {\n    if (SetCanceledEvent.is(e)) {\n        setCanceled(cancellationPath(e.data.id), e.source.id);\n    } else if (DeleteCanceledEvent.is(e)) {\n        deleteCanceled(cancellationPath(e.data.id), e.source.id);\n    }\n});\n\nasync function clientLog(clientId: string, m: string) {\n    const client = await self.clients.get(clientId);\n    const message: SwLogMessage = { type: 'log', message: m };\n    client?.postMessage(message);\n}\n\nself.addEventListener('fetch', (e) => {\n    const request = e.request;\n    debug && clientLog(e.clientId, `fetch ${request.method} ${request.url}`);\n\n    const u = new URL(request.url);\n\n    if (u.host !== self.location.host) {\n        return;\n    }\n\n    if (isCancellationPath(u.pathname)) {\n        switch (request.method) {\n            case 'GET':\n                e.respondWith(getCanceledResponse(u.pathname, e.clientId));\n                break;\n            // Alternative cancellation triggering method; see page.ts\n            case 'POST':\n                e.respondWith(setCanceledResponse(u.pathname, e.clientId));\n                break;\n            case 'DELETE':\n                e.respondWith(deleteCanceledResponse(u.pathname, e.clientId));\n                break;\n        }\n    } else if (isRpcPath(u.pathname)) {\n        e.respondWith(rpcResponse(request, e.clientId));\n    }\n});\n\nfunction clientRpcCall(client: Client, request: RpcRequest): Promise<RpcResponse> {\n    return new Promise((resolve) => {\n        const { port1: receiver, port2: sender } = new MessageChannel();\n        receiver.onmessage = (e) => resolve(e.data);\n        const message: SwRpcMessage = { type: 'rpc', request, port: sender };\n        client.postMessage(message, [sender]);\n    });\n}\n\nasync function rpcResponse(request: Request, clientId: string): Promise<Response> {\n    const client = await self.clients.get(clientId);\n    if (!client) {\n        return new Response('no client', { status: 500 });\n    }\n\n    const body: RpcRequest = await request.json();\n    const response = await clientRpcCall(client, body);\n    return new Response(JSON.stringify(response), { status: 200 });\n}\n\ndebug && console.log('sw: loaded');\n"],
  "mappings": "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",
  "names": []
}
